keywords/hints: dont have to check every number, chinese remainder, successive substitution, congruence

ok, part 1 was pretty easy.... part 2 was a journey, but a good one.


The first try was to brute-force it. I mean, after all ... one time has to be the right one... After calculating for ~20 min I thought that might not work as well as I hoped... Later i found aout it would hav found the solution... in 2324. (Execution time ~ 300a)

So i began thinking. The largest number in my input is 823. so when this number matches (time 804), it wont match again for the next 823 iterations. So why am i calculating them? I started calculating at 804 with steps of 823. Soon I thought the second largest one is 443. So if i check it right at the beginning of the loop, i can skip most of it in 442/443 cases. The same goes for the next numbers.

But the Execution time was still bad. So i began thinking about a way to skip those 442 cases entirely. There must be a point where both (823 and 443) match at the same time for the first time. after that point those matches should be regulary with a peroid length of 823 * 443 = 364 589. Since my calculation was still running, I wrote a helper script (h.py) to help me calculate that first point. I searched for not the first point but the first after my current number (the calculation was running in the background all the time and i printed the current number to the console so I didnt waste time recalulating things I already knew). After that I did the same for the third largest number (41) so ended with step width 14 948 149. That brought me a result within 15 seconds.

The part was solved but i wasnt happy with the code, since i had various handmade calculations and thus numbers like stepwidth came from nowhere. So I thought about a way to automatise the algorithm I used. The result was 2_sub.py. Basicly its like this: Start at position (offset) 1 with step width 1. For every element in the input wich is no "x", check where the condition (arrived n minutes after the first bus) is given. This is automaticly the first occurance of this condition (since we start at 1). After this the condition is met every <element> times the current step-width. So step-width gets multiplied with <element>. After going through the whole input the resulting offset is the first occurance where all the buses come at the designated offsets to the first one. With the step width one could easily calculate when the next how-many-you-want times this would happen. The new code executes in less than 50 ms. Here is a visualization of how it works: https://streamable.com/tojflp

After that i decided to look around reddit what other people did to that day. Turns out I was by far not the only one failing to brute-force that problem. But there was one entry which caught my attention: A joke about how google requests for "chinese remainder" (ger: Chinesischer Restklassensatz) skyrocketed after the puzzle was out... well as far as google requests for chinese algebra can skyrocket...(https://www.reddit.com/r/adventofcode/comments/kc5bl5/weird_math_trick_goes_viral/) I looked into it and found out a few things: First, the problem we are facing has a name "Congruence" (ger: Simultane Kongruenz). Second, there are two solutions. Third, the solution I developed is one of them, called successive substitution (ger: sukzessive Substitution). Third, the other solution is the chinese remainder. It works in several steps, which are easy to follow if they are explained using an easy example like here: https://www.youtube.com/watch?v=oXPUe0c-iR0 (german)

I decided to implement that algorithm too. After that I was astonished how well this puzzle was made. Its nearly impossible to brute-force directly (though a guy on reddit is tempted to try it using a super-cluster) but it is easy and fast to solve once you notice you dont have to check every number. All that with a really short script (20/35 lines for substitution/chinese remainder). Also i finally understood the chinese remainder theorem. Well not understood entirely, but I can use it and thats what matters for me.
